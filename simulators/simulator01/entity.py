class EnergyManager:
    """Manages the energy of an entity."""

    def __init__(self, initial_energy=100, max_energy=200, energy_per_cycle=1):
        """
        Initializes the EnergyManager.

        Args:
            initial_energy (int): The starting energy level.
            max_energy (int): The maximum energy level.
            base_energy_per_cycle (int): The base energy cost per simulation cycle.
        """
        self.current_energy = initial_energy
        self.max_energy = max_energy
        self.base_energy_per_cycle = base_energy_per_cycle

    def gain_energy(self, amount):
        """
        Increases current energy by the given amount, up to max_energy.

        Args:
            amount (int): The amount of energy to gain.
        """
        self.current_energy = min(self.max_energy, self.current_energy + amount)

    def lose_energy(self, amount):
        """
        Decreases current energy by the given amount.

        Args:
            amount (int): The amount of energy to lose.

        Returns:
            bool: True if energy drops to 0 or below, False otherwise.
        """
        self.current_energy -= amount
        return self.current_energy <= 0

    def metabolic_cost(self, trait_manager=None):
        """
        Decreases current energy by the calculated energy_per_cycle,
        influenced by the Destructiveness trait if trait_manager is provided.

        Args:
            trait_manager (TraitManager, optional): The entity's trait manager.

        Returns:
            bool: True if energy drops to 0 or below, False otherwise.
        """
        current_energy_per_cycle = self.base_energy_per_cycle
        if trait_manager and trait_manager.has_trait("Destructiveness"):
            destructiveness_score = trait_manager.get_trait("Destructiveness")

            # metabolic_multiplier: 0.8 (trait 0.0) up to 1.2 (trait 1.0). Neutral 0.5 -> 1.0
            metabolic_multiplier = 0.8 + (destructiveness_score * 0.4)
            current_energy_per_cycle = round(self.base_energy_per_cycle * metabolic_multiplier)
            current_energy_per_cycle = max(0, current_energy_per_cycle) # Ensure it's not negative
            # print(f"Destr: {destructiveness_score:.2f}, MetM: {metabolic_multiplier:.2f}, EffEPC: {current_energy_per_cycle}") # Optional Debug

        self.current_energy -= current_energy_per_cycle
        return self.current_energy <= 0


class CoreProcessor:
    """Handles information processing for an entity."""

    def __init__(self, base_processing_cost=10, value_increment=5):
        """
        Initializes the CoreProcessor.

        Args:
            base_processing_cost (int): The base energy cost to process information.
            value_increment (int): The base amount of value generated by processing.
        """
        self.base_processing_cost = base_processing_cost
        self.base_value_increment = value_increment
        self.value_generated = 0 # Cumulative value

    def get_effective_processing_cost(self, trait_manager=None):
        """
        Calculates and returns the effective processing cost based on the Calculation trait.

        Args:
            trait_manager (TraitManager, optional): The entity's trait manager.

        Returns:
            int: The effective processing cost.
        """
        current_processing_cost = self.base_processing_cost
        if trait_manager and trait_manager.has_trait("Calculation"):
            calculation_score = trait_manager.get_trait("Calculation")
            cost_multiplier = 1.2 - (calculation_score * 0.4) # 1.2 down to 0.8
            current_processing_cost = round(self.base_processing_cost * cost_multiplier)
            current_processing_cost = max(1, current_processing_cost) # Ensure cost is at least 1
        return current_processing_cost

    def process_information(self, energy_manager, trait_manager=None):
        """
        Processes information if there is enough energy, considering trait effects.
        The actual energy cost and value generated are influenced by the Calculation trait.

        Args:
            energy_manager (EnergyManager): The entity's energy manager.
            trait_manager (TraitManager, optional): The entity's trait manager.

        Returns:
            bool: True if processing was successful, False otherwise.
        """
        current_processing_cost = self.get_effective_processing_cost(trait_manager)
        current_value_increment = self.base_value_increment

        if trait_manager and trait_manager.has_trait("Calculation"):
            calculation_score = trait_manager.get_trait("Calculation")
            # Affect value_increment
            # value_multiplier: 0.8 (trait 0.0) up to 1.2 (trait 1.0). Neutral 0.5 -> 1.0
            value_multiplier = 0.8 + (calculation_score * 0.4)
            current_value_increment = round(self.base_value_increment * value_multiplier)
            current_value_increment = max(0, current_value_increment) # Ensure value is not negative
            # print(f"Calc: {calculation_score:.2f}, CostM: (handled in get_effective_processing_cost), ValM: {value_multiplier:.2f}, EffCost: {current_processing_cost}, EffVal: {current_value_increment}") # Optional Debug

        if energy_manager.current_energy >= current_processing_cost:
            energy_manager.lose_energy(current_processing_cost)
            self.value_generated += current_value_increment
            return True
        return False


class AdaptationEngine:
    """Handles adaptation mechanisms for an entity."""

    def __init__(self, adaptation_threshold=50):
        """
        Initializes the AdaptationEngine.

        Args:
            adaptation_threshold (int): The energy level below which adaptation might occur.
        """
        self.adaptation_threshold = adaptation_threshold

    def adapt(self, energy_manager, core_processor):
        """
        Adapts the entity's properties based on its energy level.

        Args:
            energy_manager (EnergyManager): The entity's energy manager.
            core_processor (CoreProcessor): The entity's core processor.
        """
        if energy_manager.current_energy < self.adaptation_threshold:
            if core_processor.processing_cost > 1:
                core_processor.processing_cost = max(1, core_processor.processing_cost - 1)
                print(f"Adapting: Reduced processing cost to {core_processor.processing_cost}")


class ReproductionManager:
    """Manages the reproduction process for an entity."""

    def __init__(self, reproduction_cost=50, energy_threshold_for_reproduction=150):
        """
        Initializes the ReproductionManager.

        Args:
            reproduction_cost (int): The energy cost to reproduce.
            energy_threshold_for_reproduction (int): The minimum energy required to reproduce.
        """
        self.reproduction_cost = reproduction_cost
        self.energy_threshold_for_reproduction = energy_threshold_for_reproduction

    def should_reproduce(self, current_energy, trait_manager=None):
        """
        Checks if the entity has enough energy to consider reproduction,
        factoring in Cautiousness and RiskTaking from the trait_manager if provided.

        Args:
            current_energy (int): The current energy of the entity.
            trait_manager (TraitManager, optional): The entity's trait manager.

        Returns:
            bool: True if energy is above or equal to the effective threshold (adjusted for traits), False otherwise.
        """
        effective_threshold = self.energy_threshold_for_reproduction
        if trait_manager:
            cautiousness_score = trait_manager.get_trait("Cautiousness")
            # threshold_multiplier: 0.8 (trait 0.0) to 1.2 (trait 1.0). Neutral 0.5 -> 1.0
            threshold_multiplier = 0.8 + (cautiousness_score * 0.4)
            effective_threshold = round(self.energy_threshold_for_reproduction * threshold_multiplier)
            # print(f"Cautiousness {cautiousness_score:.2f}, base repro_thresh {self.energy_threshold_for_reproduction}, effective {effective_threshold}") # Optional debug

        if trait_manager and trait_manager.has_trait("RiskTaking"): # Check if trait exists
            risk_taking_score = trait_manager.get_trait("RiskTaking")
            # risk_multiplier_repro: 1.1 (trait 0.0) to 0.9 (trait 1.0). Neutral 0.5 -> 1.0
            risk_multiplier_repro = 1.1 - (risk_taking_score * 0.2)
            effective_threshold = round(effective_threshold * risk_multiplier_repro)
            # print(f"RiskTaking {risk_taking_score:.2f}, risk_mult_repro {risk_multiplier_repro:.2f}, final effective_thresh {effective_threshold}") # Optional debug

        return current_energy >= effective_threshold

    def reproduce(self, energy_manager, entity_id_str, trait_manager=None):
        """
        Attempts to deduct energy for reproduction if conditions are met.
        The decision to reproduce (should_reproduce) considers Cautiousness and RiskTaking via trait_manager.

        Args:
            energy_manager (EnergyManager): The energy manager of the entity.
            entity_id_str (str): The string representation of the entity's ID for logging.
            trait_manager (TraitManager, optional): The entity's trait manager.


        Returns:
            bool: True if reproduction cost was successfully deducted, False otherwise.
        """
        if self.should_reproduce(energy_manager.current_energy, trait_manager):
            if energy_manager.current_energy >= self.reproduction_cost:
                 energy_manager.lose_energy(self.reproduction_cost)
                 print(f"Entity {entity_id_str} reproductive systems active (energy cost deducted).")
                 return True
        return False


class TraitManager:
    """Manages an entity's traits and their scores."""
    def __init__(self, initial_traits=None):
        """
        Initializes the TraitManager.

        Args:
            initial_traits (dict, optional): A dictionary of initial traits and their scores.
                                             Example: {"Acquisitiveness": 0.7, "Cautiousness": 0.3}
        """
        self.traits = {}
        if initial_traits:
            self.traits.update(initial_traits)

    def get_trait(self, trait_name, default_value=0.5):
        """
        Gets the score of a trait, returning a default if not present.

        Args:
            trait_name (str): The name of the trait.
            default_value (float, optional): The value to return if the trait is not found. Defaults to 0.5.

        Returns:
            float: The score of the trait, or the default value.
        """
        return self.traits.get(trait_name, default_value)

    def set_trait(self, trait_name, score):
        """
        Sets the score of a trait. Scores are expected to be between 0.0 and 1.0.
        Scores outside this range will be clamped.

        Args:
            trait_name (str): The name of the trait to set.
            score (float): The score of the trait (ideally 0.0 to 1.0).
        """
        if not (0.0 <= score <= 1.0):
            original_score = score
            score = max(0.0, min(1.0, score))
            print(f"Warning: Trait {trait_name} score {original_score} clamped to {score}.")
        self.traits[trait_name] = score

    def has_trait(self, trait_name):
        """
        Checks if a trait is present in the manager.

        Args:
            trait_name (str): The name of the trait.

        Returns:
            bool: True if the trait exists, False otherwise.
        """
        return trait_name in self.traits

    def __str__(self):
        """Returns a string representation of the traits."""
        return str(self.traits)


class Attentiophage:
    """Represents an Attentiophage entity in the simulation."""

    def __init__(self, entity_id, initial_energy=100, max_energy=200,
                 base_energy_per_cycle=1, # <-- Renamed
                 base_processing_cost=10, base_value_increment=5,
                 harvest_amount=20,
                 reproduction_cost=50, energy_threshold_for_reproduction=150,
                 initial_traits=None, **kwargs):
        """
        Initializes an Attentiophage.

        Args:
            entity_id (str): A unique identifier for the entity.
            initial_energy (int): The starting energy level.
            max_energy (int): The maximum energy level.
            base_energy_per_cycle (int): The base energy cost per simulation cycle for the energy manager.
            base_processing_cost (int): The base energy cost for the core processor.
            base_value_increment (int): The base value generated by the core processor.
            harvest_amount (int): The amount of energy the entity attempts to harvest.
            reproduction_cost (int): The energy cost for reproduction.
            energy_threshold_for_reproduction (int): The energy level needed to reproduce.
            initial_traits (dict, optional): Initial traits for the entity's TraitManager.
            **kwargs: Additional keyword arguments.
        """
        self.entity_id = entity_id
        self.energy_manager = EnergyManager(initial_energy, max_energy,
                                            base_energy_per_cycle=base_energy_per_cycle) # <-- Pass new param name
        self.core_processor = CoreProcessor(base_processing_cost=base_processing_cost,
                                            value_increment=base_value_increment)
        self.harvest_amount = harvest_amount
        self.adaptation_engine = AdaptationEngine()  # Default adaptation_threshold
        self.is_alive = True
        self.reproduction_manager = ReproductionManager(reproduction_cost, energy_threshold_for_reproduction)

        # Initialize TraitManager
        default_traits = {
            "Acquisitiveness": 0.5,
            "Cautiousness": 0.5,
            "RiskTaking": 0.5,      # Renamed from Risk-taking for easier attribute access if needed
            "Calculation": 0.5,
            "Destructiveness": 0.5
        }
        # Update defaults with any provided initial_traits
        if initial_traits:
            default_traits.update(initial_traits)
        self.trait_manager = TraitManager(default_traits)

    def perform_cycle_actions(self, environment):
        """
        Performs the actions for one simulation cycle.

        Args:
            environment (Environment): The environment in which the entity exists.
        """
        if not self.is_alive:
            return

        # Get Acquisitiveness score
        acquisitiveness_score = self.trait_manager.get_trait("Acquisitiveness") # Defaults to 0.5 if not found

        # Calculate effective harvest amount based on trait
        # Base harvest amount is self.harvest_amount (the parameter passed during init)
        # Multiplier: 0.5 (at trait 0.0) to 1.5 (at trait 1.0)
        # Neutral trait 0.5 results in 1.0 multiplier
        harvest_multiplier = 0.5 + acquisitiveness_score
        effective_harvest_amount = round(self.harvest_amount * harvest_multiplier)

        # Ensure it's not negative if base harvest_amount was small and score was 0
        effective_harvest_amount = max(0, effective_harvest_amount)

        # Attempt to harvest attention using the effective amount
        # print(f"Entity {self.entity_id} (Acq: {acquisitiveness_score:.2f}) attempts to harvest {effective_harvest_amount} (base: {self.harvest_amount})") # Optional: for debugging
        harvested_energy = environment.provide_attention(effective_harvest_amount)
        self.energy_manager.gain_energy(harvested_energy)
        # Optional: print(f"Entity {self.entity_id} harvested {harvested_energy} energy.")

        # Processing logic modification
        can_process_based_on_caution = True
        cautiousness_score = self.trait_manager.get_trait("Cautiousness")

        # Cautiousness influences decision to process information
        # safety_factor: 1.0 (trait 0.0) to 1.5 (trait 1.0). Neutral 0.5 -> 1.25
        processing_safety_factor = 1.0 + (cautiousness_score * 0.5)

        # Apply RiskTaking to processing_safety_factor
        if self.trait_manager.has_trait("RiskTaking"): # Check if trait exists
            risk_taking_score = self.trait_manager.get_trait("RiskTaking")
            # risk_multiplier_proc: 1.1 (trait 0.0) to 0.9 (trait 1.0). Neutral 0.5 -> 1.0
            risk_multiplier_proc = 1.1 - (risk_taking_score * 0.2)
            processing_safety_factor *= risk_multiplier_proc # Modify the existing factor
            # print(f"RiskTaking {risk_taking_score:.2f}, risk_mult_proc {risk_multiplier_proc:.2f}, final safety_factor {processing_safety_factor:.2f}") # Optional debug

        # Get current effective processing cost from CoreProcessor, considering Calculation trait
        effective_proc_cost = self.core_processor.get_effective_processing_cost(self.trait_manager)

        required_energy_for_processing = effective_proc_cost * processing_safety_factor # processing_safety_factor already includes Cautiousness & RiskTaking

        if self.energy_manager.current_energy < required_energy_for_processing:
            can_process_based_on_caution = False
            # print(f"Entity {self.entity_id} (Cautious: {cautiousness_score:.2f}) avoids processing. Energy {self.energy_manager.current_energy}/{required_energy_for_processing:.2f} needed.") # Optional debug

        # Original processing call, now conditional on caution as well
        if can_process_based_on_caution and self.core_processor.process_information(self.energy_manager, self.trait_manager):
            # Processing occurred
            # print(f"Entity {self.entity_id} processed information.") # Optional debug
            pass
        else:
            # Processing did not occur, either due to caution or insufficient direct funds
            # print(f"Entity {self.entity_id} did not process. Caution: {not can_process_based_on_caution}, Funds: {self.energy_manager.current_energy < effective_proc_cost}") # Optional debug
            pass

        self.adaptation_engine.adapt(self.energy_manager, self.core_processor)

        # Attempt reproduction
        # Check should_reproduce first to avoid unnecessary calls if obvious not enough energy
        if self.reproduction_manager.should_reproduce(self.energy_manager.current_energy, self.trait_manager):
            # The reproduce method now only deducts energy and signals success
            if self.reproduction_manager.reproduce(self.energy_manager, str(self.entity_id), self.trait_manager):
                # If energy was deducted, then ask environment to spawn offspring
                offspring_config = {
                    "initial_energy": self.energy_manager.max_energy // 2, # Start with decent energy
                    "max_energy": self.energy_manager.max_energy,
                    "energy_per_cycle": self.energy_manager.energy_per_cycle,
                    "base_processing_cost": self.core_processor.base_processing_cost,
                    "base_value_increment": self.core_processor.base_value_increment,
                    "harvest_amount": self.harvest_amount,
                    "reproduction_cost": self.reproduction_manager.reproduction_cost,
                    "energy_threshold_for_reproduction": self.reproduction_manager.energy_threshold_for_reproduction,
                    "base_energy_per_cycle": self.energy_manager.base_energy_per_cycle, # Add this
                    # Offspring will inherit parent's traits by default if not specified
                    "initial_traits": self.trait_manager.traits.copy()
                }
                environment.add_offspring(offspring_config)

        if self.energy_manager.metabolic_cost(self.trait_manager):
            self.is_alive = False
            # print(f"Entity {self.entity_id} has run out of energy and died.") # Optional debug
            print(f"Entity {self.entity_id} has run out of energy.")
